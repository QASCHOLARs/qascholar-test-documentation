== Retries

A retry is an attempt to re-execute a failed test. Tests can fail for various reasons, such as transient network issues, temporary unavailability of external services, or other intermittent problems. By configuring retries, you can increase the chances of a test completing successfully without manual intervention.

When a test fails, the system will automatically retry the test based on the configured retry policy. This policy can include parameters such as the maximum number of retries.

Retries can be configured at different levels, such as globally for all tests, or specifically for individual test cases. This flexibility allows you to tailor the retry behavior to the needs of your testing environment.

Retries can be particularly useful in scenarios where tests are known to be flaky or when dealing with external dependencies that may not always be reliable. However, it's important to use retries judiciously, as excessive retries can mask underlying issues that need to be addressed.

When configuring retries, consider the following best practices:
- Set a reasonable limit on the number of retries to avoid infinite loops.
- Implement a backoff strategy to space out retries, reducing the load on the system.   
- Monitor the results of retries to identify patterns of failure that may indicate deeper issues.
- Use retries in conjunction with other testing strategies, such as test isolation and mocking, to improve overall test reliability.
- Document the retry policy clearly so that all team members understand how retries are handled.

By effectively managing retries, you can enhance the robustness of your testing process and improve the reliability of your test results. Consider implementing a backoff strategy, such as a fixed delay or exponential backoff, to avoid overwhelming the system with rapid retry attempts.

Retries can be particularly useful in scenarios where tests are known to be flaky or when dealing with external dependencies that may not always be reliable. However, it's important to use retries judiciously, as excessive retries can mask underlying issues that need to be addressed.

Playwright, for example, provides built-in support for retries, allowing you to configure the number of retry attempts for individual tests or globally across your test suite. This can be done using the `retries` option in the Playwright test configuration.

set the retries option in the Playwright test configuration file (e.g., `playwright.config.js` or `playwright.config.ts`):

[source,js]
----
import { defineConfig } from '@playwright/test';
export default defineConfig({
  retries: 2, // Retry failed tests up to 2 times
});
----

set the retries option for individual tests or test suites using the `test` or `test.describe` methods:

[source,js]
----
import { test } from '@playwright/test';
test.describe.configure({ retries: 2 }); // Retry failed tests in this suite up to 2 times

test('example test with retries-1', async ({ page }) => {
  // Test code here
});
test('example test with retries-2', async ({ page }) => {
  // Test code here
});
test('example test with retries-3', async ({ page }) => {
  // Test code here
});
----

Playwright will automatically retry any failed tests according to the configured retry policy, helping to mitigate transient issues and improve the overall reliability of your test suite.

PlayWright Test categorize the tests as follows:

- **Passed**: Tests that completed successfully on the first attempt.
- **Failed**: Tests that failed after all retry attempts were exhausted.
- **Flaky**: Tests that initially failed but passed on a subsequent retry attempt.
- **Skipped**: Tests that were not executed, often due to being conditionally skipped based on certain criteria.
- **Timed Out**: Tests that did not complete within the specified time limit, even after retries.
- **Interrupted**: Tests that were halted due to external factors, such as a manual stop or system shutdown.    
- **Expected to Fail**: Tests that are marked as expected to fail, which can be useful for tracking known issues without affecting the overall test results.
- **Unexpectedly Passed**: Tests that were expected to fail but passed, indicating a potential fix or change in behavior.

By analyzing these categories, you can gain insights into the stability and reliability of your test suite, identify flaky tests that may need further investigation, and ensure that your testing process is robust and effective.

For more detailed information on configuring retries in Playwright, refer to the official Playwright documentation on [Retries](https://playwright.dev/docs/test-retries).

To retrieve information about retries in your test results, you can use the Playwright Test Reporter API. This allows you to access detailed information about each test run, including the number of retries and their outcomes.

Here is an example of how to implement a custom reporter to log retry information:

[source,js]
----
import { Reporter, TestCase, TestResult } from '@playwright/test/reporter';
class RetryReporter implements Reporter {
  onTestEnd(test: TestCase, result: TestResult) {
    if (result.status === 'failed' && result.retryCount > 0) {
      console.log(`Test "${test.title}" failed after ${result.retryCount} retries.`);
    } else if (result.status === 'passed' && result.retryCount > 0) {
      console.log(`Test "${test.title}" passed after ${result.retryCount} retries.`);
    }
  }     
}
export default RetryReporter;
----
To use this custom reporter, add it to your Playwright configuration file:
[source,js]
----
import { defineConfig } from '@playwright/test';
import RetryReporter from './path/to/RetryReporter';
export default defineConfig({
  reporter: [['list'], [RetryReporter]], // Add the custom reporter
  retries: 2, // Configure global retries if needed
}); 
----
This custom reporter will log messages to the console whenever a test fails or passes after one or more retries, providing insights into the retry behavior of your tests.


Lets dive deeper into a few examples to understand the worker execution flow and how retries are handled.

*Consider the following test suite with five tests and understand how the worker executes them.*

[source,js]
----
const { test, expect } = require('@playwright/test');

test.describe('Flow Example', () => {
  test.beforeEach(async ({ page }, testInfo) => {
    console.log(
      `Running test: ${testInfo.title}, attempt: ${testInfo.retry}, workerID: ${testInfo.workerIndex}`
    );
  });
  test('Test1', async ({ page }) => {
    console.log('Executing Test1');
  });

  test('Test2', async ({ page }) => {
    console.log('Executing Test2');
  });

  test('Test3', async ({ page }) => {
    console.log('Executing Test3');
  });

  test('Test4', async ({ page }) => {
    console.log('Executing Test4');
  });
  test('Test5', async ({ page }) => {
    console.log('Executing Test5');
  });
});
----
In this example, we have a test suite with five tests. The `beforeEach` hook logs the test title, retry attempt, and worker ID before each test execution. When you run this test suite with retries enabled, you will see how each test is executed.

When you run the above test suite without retries, the output will look something like this for the initial execution:

[source]
----
Running 5 tests using 1 worker
Running test: Flow Example Test1, *attempt: 0*, *workerID: 0*
Executing Test1
Running test: Flow Example Test2, *attempt: 0*, *workerID: 0*
Executing Test2
Running test: Flow Example Test3, *attempt: 0*, *workerID: 0*
Executing Test3
Running test: Flow Example Test4, *attempt: 0*, *workerID: 0*
Executing Test4
Running test: Flow Example Test5, *attempt: 0*, *workerID: 0*
Executing Test5
----

A worker with *workerID 0* executes all tests sequentially. Each test runs once, and the attempt count is 0 for all tests. The worker with *workerID 0* handles all test executions and spawns and closes the worker at the end of the test run. This flow is straightforward when there are no retries.

*Consider the following test suite with five tests and understand how the worker executes them when one of the tests fails.*

[source,js]
-----
const { test, expect } = require('@playwright/test');

test.describe('Flow Example', () => {
  test.beforeEach(async ({ page }, testInfo) => {
    console.log(
      `Running test: ${testInfo.title}, attempt: ${testInfo.retry}, workerID: ${testInfo.workerIndex}`
    );
  });
  test('Test1', async ({ page }) => {
    console.log('Executing Test1');
  });

  test('Test2', async ({ page }) => {
    console.log('Executing Test2');
  });

  test('Test3', async ({ page }) => {
    console.log('Executing Test3 with intentional failure ');
    //test.fail(true, 'Intentional Failure to demonstrate retries');
    throw new Error('Intentional Failure to demonstrate retries');
  });

  test('Test4', async ({ page }) => {
    console.log('Executing Test4');
  });
  test('Test5', async ({ page }) => {
    console.log('Executing Test5');
  });
});
-----
When you run this test suite with retries without enabled, the output will look something like this:[source,js]
----
Running 5 tests using 1 worker
Running test: Flow Example Test1, *attempt: 0*, *workerID: 0*
Executing Test1
Running test: Flow Example Test2, *attempt: 0*, *workerID: 0*
Executing Test2
Running test: Flow Example Test3, *attempt: 0*, *workerID: 0*
Executing Test3 with intentional failure
Running test: Flow Example Test4, *attempt: 0*, *workerID: 1*
Executing Test4
Running test: Flow Example Test5, *attempt: 0*, *workerID: 1*
Executing Test5
----

In this scenario, the worker with *workerID 0* executes Test1, Test2, and Test3. Since Test3 fails, the worker spawns a new worker with *workerID 1* to continue executing the remaining tests (Test4 and Test5). The attempt count remains 0 for all tests since there are no retries configured and the failed test is not retried. This flow demonstrates how the system handles test failures by spawning new workers to continue test execution, but not the retries.


*Consider the following test suite with five tests and understand how the worker executes them when one of the tests fails and retries are enabled.*

[source,js]
----

const { test, expect } = require('@playwright/test');

test.describe.configure({ retries: 2 }); //retry failed tests up to 2 times

test.describe('Retries Example', () => {
  test.beforeEach(async ({ page }, testInfo) => {
    console.log(
      `Running test: ${testInfo.title}, attempt: ${testInfo.retry}, workerID: ${testInfo.workerIndex}`
    );
  });
  test('Test1', async ({ page }) => {
    console.log('Executing Test1');
  });

  test('Test2', async ({ page }) => {
    console.log('Executing Test2');
  });

  test('Test3', async ({ page }) => {
    console.log('Executing Test3 but failed intentionally');
    //test.fail(true, 'Intentional Failure to demonstrate retries');
    throw new Error('Intentional Failure to demonstrate retries');
  });

  test('Test4', async ({ page }) => {
    console.log('Executing Test4');
  });

  test('Test5', async ({ page }) => {
    console.log('Executing Test5');
  });
});
----
When you run this test suite with retries enabled, the output will look something like this:[source]
----
Running 5 tests using 1 worker

  ✓  1 retries-flow-with-retries.spec.js:17:3 › Retries Example › Test1 (107ms)
Running test: Test1, attempt: 0, workerID: 0
Executing Test1
  ✓  2 retries-flow-with-retries.spec.js:21:3 › Retries Example › Test2 (68ms)
Running test: Test2, attempt: 0, workerID: 0
Executing Test2
  ✘  3 retries-flow-with-retries.spec.js:25:3 › Retries Example › Test3 (172ms)
Running test: Test3, attempt: 0, workerID: 0
Executing Test3 but failed intentionally
  ✘  4 retries-flow-with-retries.spec.js:25:3 › Retries Example › Test3 (retry #1) (151ms)
Running test: Test3, attempt: 1, workerID: 1
Executing Test3 but failed intentionally
  ✘  5 retries-flow-with-retries.spec.js:25:3 › Retries Example › Test3 (retry #2) (128ms)
Running test: Test3, attempt: 2, workerID: 2
Executing Test3 but failed intentionally
  ✓  6 retries-flow-with-retries.spec.js:31:3 › Retries Example › Test4 (145ms)
Running test: Test4, attempt: 0, workerID: 3
Executing Test4
  ✓  7 retries-flow-with-retries.spec.js:35:3 › Retries Example › Test5 (69ms)
Running test: Test5, attempt: 0, workerID: 3
Executing Test5

1 failed
    retries-flow-with-retries.spec.js:25:3 › Retries Example › Test3 ───────────────────────────────
  4 passed (5.4s)
----
In this scenario, the worker with *workerID 0* executes Test1, Test2, and Test3. Since Test3 fails on the first attempt, the system spawns a new worker with *workerID 1* to retry Test3. When Test3 fails again, another worker with *workerID 2* is spawned for the second retry. After exhausting all retries for Test3, the system spawns a new worker with *workerID 3* to continue executing the remaining tests (Test4 and Test5). The attempt count increments with each retry for Test3, while it remains 0 for the other tests that pass on their first attempt. This flow demonstrates how retries are handled in conjunction with worker management in Playwright Test. 

*Please note that at any point time one worker is active and executing the tests, the worker spawns new workers only when a test fails and needs to be retried.*  


*Consider the following test suite with serial mode with five tests and understand how the worker executes them when one of the tests fails*

[source,js]
----

const { test, expect } = require('@playwright/test');

test.describe.configure({ mode: 'serial'});

test.describe('Retries Example', () => {
  test.beforeEach(async ({ page }, testInfo) => {
    console.log(
      `Running test: ${testInfo.title}, attempt: ${testInfo.retry}, workerID: ${testInfo.workerIndex}`
    );
  });

  test('Test1', async ({ page }) => {
    console.log('Executing Test1');
  });

  test('Test2', async ({ page }) => {
    console.log('Executing Test2');
  });

  test('Test3', async ({ page }) => {
    console.log('Executing Test3');
    throw new Error('Intentional Failure to demonstrate retries');
  });
  test('Test4', async ({ page }) => {
    console.log('Executing Test4');
  });
  test('Test5', async ({ page }) => {
    console.log('Executing Test5');
  });
});
----
When you run this test suite with serial mode enabled, the output will look something like this:[source]
----
Running 5 tests using 1 worker

  ✓  1 …st-describe-mode-serial-with-no-retries.spec.js:14:3 › Retries Example › Test1 (139ms)
Running test: Test1, attempt: 0, workerID: 0
Executing Test1
  ✓  2 …st-describe-mode-serial-with-no-retries.spec.js:18:3 › Retries Example › Test2 (126ms)
Running test: Test2, attempt: 0, workerID: 0
Executing Test2
  ✘  3 test-describe-mode-serial-with-no-retries.spec.js:22:3 › Retries Example › Test3 (96ms)
Running test: Test3, attempt: 0, workerID: 0
Executing Test3
  -  4 test-describe-mode-serial-with-no-retries.spec.js:27:3 › Retries Example › Test4       
  -  5 test-describe-mode-serial-with-no-retries.spec.js:30:3 › Retries Example › Test5
  1 failed
    test-describe-mode-serial-with-no-retries.spec.js:22:3 › Retries Example › Test3 ─────────
  2 did not run
  2 passed (1.6s)
----

In this scenario, the worker with *workerID 0* executes Test1, Test2, and Test3 sequentially. Since Test3 fails, the execution stops immediately due to the serial mode configuration, and Test4 and Test5 are not executed. The attempt count remains 0 for all tests since there are no retries configured. This flow demonstrates how serial mode affects test execution by halting further tests upon a failure.


*Consider the following test suite with serial mode with five tests and understand how the worker executes them when one of the tests fails and retries are enabled*

[source,js]
----
const { test, expect } = require('@playwright/test');

test.describe.configure({ mode: 'serial', retries: 2 });

test.describe('Retries Example', () => {
  test.beforeEach(async ({ page }, testInfo) => {
    console.log(
      `Running test: ${testInfo.title}, attempt: ${testInfo.retry}, workerID: ${testInfo.workerIndex}`
    );
  });

  test('Test1', async ({ page }) => {
    console.log('Executing Test1');
  });

  test('Test2', async ({ page }) => {
    console.log('Executing Test2');
  });

  test('Test3', async ({ page }) => {
    console.log('Executing Test3');
    //test.fail(true, 'Intentional Failure to demonstrate retries');
    throw new Error('Intentional Failure to demonstrate retries');
  });
  test('Test4', async ({ page }) => {
    console.log('Executing Test4');
  });
  test('Test5', async ({ page }) => {
    console.log('Executing Test5');
  });
});
----
When you run this test suite with serial mode and retries enabled, the output will look something like this:[source]  
----
Running 5 tests using 1 worker

  ✓  1 test-describe-mode-serial-with-retries.spec.js:14:3 › Retries Example › Test1 (111ms)
Running test: Test1, attempt: 0, workerID: 0
Executing Test1
  ✓  2 test-describe-mode-serial-with-retries.spec.js:18:3 › Retries Example › Test2 (75ms)
Running test: Test2, attempt: 0, workerID: 0
Executing Test2
  ✘  3 test-describe-mode-serial-with-retries.spec.js:22:3 › Retries Example › Test3 (99ms)
Running test: Test3, attempt: 0, workerID: 0
Executing Test3
  -  4 test-describe-mode-serial-with-retries.spec.js:27:3 › Retries Example › Test4
  -  5 test-describe-mode-serial-with-retries.spec.js:30:3 › Retries Example › Test5
  ✓  6 test-describe-mode-serial-with-retries.spec.js:14:3 › Retries Example › Test1 (retry #1) (99ms)
Running test: Test1, attempt: 1, workerID: 1
Executing Test1
  ✓  7 test-describe-mode-serial-with-retries.spec.js:18:3 › Retries Example › Test2 (retry #1) (69ms)
Running test: Test2, attempt: 1, workerID: 1
Executing Test2
  ✘  8 test-describe-mode-serial-with-retries.spec.js:22:3 › Retries Example › Test3 (retry #1) (99ms)
Running test: Test3, attempt: 1, workerID: 1
Executing Test3
  -  9 test-describe-mode-serial-with-retries.spec.js:27:3 › Retries Example › Test4 (retry #1)                  
  -  10 test-describe-mode-serial-with-retries.spec.js:30:3 › Retries Example › Test5 (retry #1)
  ✓  11 test-describe-mode-serial-with-retries.spec.js:14:3 › Retries Example › Test1 (retry #2) (105ms)
Running test: Test1, attempt: 2, workerID: 2
Executing Test1
  ✓  12 test-describe-mode-serial-with-retries.spec.js:18:3 › Retries Example › Test2 (retry #2) (74ms)
Running test: Test2, attempt: 2, workerID: 2
Executing Test2
  ✘  13 test-describe-mode-serial-with-retries.spec.js:22:3 › Retries Example › Test3 (retry #2) (98ms)
Running test: Test3, attempt: 2, workerID: 2
Executing Test3
  -  14 test-describe-mode-serial-with-retries.spec.js:27:3 › Retries Example › Test4 (retry #2)                 
  -  15 test-describe-mode-serial-with-retries.spec.js:30:3 › Retries Example › Test5 (retry #2)
 1 failed
    test-describe-mode-serial-with-retries.spec.js:22:3 › Retries Example › Test3 ──────────────────
  2 did not run
  2 passed (4.3s)
  ----
In this scenario, the worker with *workerID 0* executes Test1, Test2, and Test3 sequentially. Since Test3 fails on the first attempt, the execution stops immediately due to the serial mode configuration, and Test4 and Test5 are not executed. The system then spawns a new worker with *workerID 1* to retry the entire suite starting from Test1. This process repeats for the second retry with *workerID 2*. After exhausting all retries for Test3, Test4 and Test5 are never executed because the failure in Test3 prevents further execution in serial mode. The attempt count increments with each retry for all tests in the suite. This flow demonstrates how serial mode combined with retries affects test execution by halting further tests upon a failure while still allowing retries of the entire suite.
----


* Please note that the tests that are not executed by the test runner are not counted in the total test count in the summary report.*

* example: In the last example above, Test4 and Test5 were not executed in any of the attempts, hence they are not counted in the total test count in the summary report.*

*All: 3 tests, 2 passed, 1 failed, flaky tests: 0, skipped: 2*



